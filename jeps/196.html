<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii" /><meta http-equiv="Content-Type" content="text/html; charset=us-ascii" /><title>JEP 196: Nashorn Optimistic Typing</title><link rel="shortcut icon" href="/images/nanoduke.ico" /><link rel="stylesheet" type="text/css" href="/page.css" /><script type="text/javascript" src="/page.js"><noscript></noscript></script><style type="text/css" xml:space="preserve">
      TABLE { border-collapse: collapse; padding: 0px; margin: 1em 0; }
      TR:first-child TH, TR:first-child TD { padding-top: 0; }
      TH, TD { padding: 0px; padding-top: .5ex; vertical-align: baseline; text-align: left; }
      TD + TD, TH + TH { padding-left: 1em; }
      TD:first-child, TH:first-child, TD.jep { text-align: right; }
      TABLE.head TD:first-child { font-style: italic; padding-left: 2em; }
      PRE { padding-left: 2em; margin: 1ex 0; font-size: inherit; }
      TABLE PRE { padding-left: 0; margin: 0; }
      TABLE.jeps TD:first-child + TD,
      TABLE.jeps TD:first-child + TD + TD { padding-left: .5em; }
      TABLE.jeps TD:first-child,
      TABLE.jeps TD:first-child + TD,
      TABLE.jeps TD:first-child + TD + TD { font-size: smaller; }
      TABLE.jeps TD.cl { font-size: smaller; padding-right: 0; text-align: right; }
      TABLE.jeps TD.cm { font-size: smaller; padding-left: .1em; padding-right: .1em; }
      TABLE.jeps TD.cr { font-size: smaller; padding-left: 0; }
      TABLE.jeps TD.z { padding-left: 0; padding-right: 0; }
      TABLE.head TD { padding-top: 0; }
      .withdrawn { text-decoration: line-through; }
    </style></head><body><div id="main"><h1>JEP 196: Nashorn Optimistic Typing</h1><table class="head"><tr><td>Authors</td><td>Marcus Lagergren, Attila Szegedi</td></tr><tr><td>Owner</td><td>Marcus Lagergren</td></tr><tr><td>Type</td><td>Feature</td></tr><tr><td>Scope</td><td>JDK</td></tr><tr><td>Status</td><td>Closed&#8201;/&#8201;Delivered</td></tr><tr><td>Release</td><td>8u40</td></tr><tr><td>Component</td><td>core-libs&#8201;/&#8201;jdk.nashorn</td></tr><tr><td>Discussion</td><td>nashorn dash dev at openjdk dot java dot net</td></tr><tr><td>Effort</td><td>L</td></tr><tr><td>Duration</td><td>L</td></tr><tr><td>Reviewed by</td><td>Brian Goetz</td></tr><tr><td>Endorsed by</td><td>Brian Goetz</td></tr><tr><td>Created</td><td>2014/05/12 14:53</td></tr><tr><td>Updated</td><td>2014/12/05 22:14</td></tr><tr><td>Issue</td><td><a href="https://bugs.openjdk.java.net/browse/JDK-8042946">8042946</a></td></tr></table><div class="markdown"><h2 id="Summary">Summary</h2>
<p>Improve Nashorn performance by making assumptions about specific types
used in arithmetic and array indexing operations, by being prepared to
recover when those assumptions prove incorrect, and by improving the
HotSpot JVM's ability to optimize non-Java bytecode.</p>
<h2 id="Goals">Goals</h2>
<ul>
<li>
<p>Ensure, by guessing types, that bytecode generated by Nashorn
contains as many primitive unboxed operations as possible and that
runtime libraries in Nashorn use that fact.</p>
</li>
<li>
<p>Ensure, by guessing types, that bytecode generated by Nashorn uses
as much Java integer arithmetic as possible.</p>
</li>
<li>
<p>The resulting performance must be stable. We cannot degrade over
time or measure peak performance only. This would block Nashorn as an
industrial strength product.</p>
</li>
<li>
<p>Ensure that bytecode generated by Nashorn can revert optimistic
assumptions of the above type with an continuation passing/exception
throwing mechanism. This is necessary as you can't just switch out an
integer instruction to, e.g., a double instruction in bytecode without
causing verify errors and having to modify a method on the fly.</p>
</li>
<li>
<p>Ensure that the built in library functions in Nashorn are optimal
Java and use primitive types well.</p>
</li>
<li>
<p>Ensure that the JVM does a much better job of optimizing "alien"
(non-Java) bytecode for example from Nashorn or JRuby, which has
similar problems.</p>
</li>
</ul>
<h2 id="Non-goals">Non-goals</h2>
<p>This is not an effort that can be targeted by "we must be X% of the
performance of a native JavaScript runtime like v8" as the areas of
optimization are many an varying. The initial phase of the
implementation will be considered successful if it adds no more than
acceptable overhead to warmup and speeds up common JavaScript
benchmarks orders of magnitude, as the technology promises, and causes
no regressions on benchmarks targeting unexplored performance areas.</p>
<h2 id="Motivation">Motivation</h2>
<p>The Nashorn JavaScript runtime needs to cooperate with the JVM to
produce more highly performant code. Native JavaScript runtimes
typically outperform Nashorn on many tasks, such as pure number
crunching. We need to do our best to make our on-top-of-the-JVM
bytecode based solution approach that performance to as large an
extent as possible. This effort should take Nashorn performance closer
to (but probably not past, in its first iteration) native JavaScript
runtime performance.</p>
<p>Using only Object operations ("a"-prefixed-bytecodes) and
invokedynamic produces bytecode that runs too slowly on HotSpot, even
though it conservatively implements JavaScript correctly.  We are not
sure that a world containing only boxed objects and invokedynamics
will ever be fast, but there needs to be some exploration of this in
the JIT as well.</p>
<p>We need to attack this from two ways - generating bytecode that
contains as much primitives as possible and being able to revert code
when an assumption about primitive types fails. HotSpot also needs to
get better at optimizing non-Java bytecode, mainly constructs around
invokedynamic and in <code>java.lang.invoke</code>.</p>
<h2 id="Description">Description</h2>
<p>We propose the following solution, a two-fold one, for Nashorn and the
JVM respectively. Note that this is to some part speculation of what
is feasible to do in the bytecode space and what the JVM will be able
to optimize. Thus, there is still some research scope, both for
Nashorn and the JVM in this proposal.</p>
<h3 id="For-Nashorn">For Nashorn</h3>
<p>We know that hardcoding explicit types at compile time gives us a
significant performance boost of the resulting bytecode. An
interesting thesis project would be to code up a TypeScript frontend
for Nashorn to show this concept. This is something that should be
done anyway in the interest of dynamic language implementations on the
JVM.</p>
<p><strong>Creating optimistic methods</strong></p>
<p>We need to generate optimistic methods based on callsite types
known at runtime (code for this is in place already but
disabled). That is, if a method is called with integer parameters, we can
generate a specialized version for that method.</p>
<p><strong>Gradual deoptimization</strong></p>
<p>We also need to generate intra-method code that is optimistic, i.e., use
integer additions even when the compiler can't statically prove that we
are dealing with <code>int</code>s, assuming that in fact we are. If we are wrong we
need to be able to generate a new version of the code that no longer
holds the wrong assumption (and is thus somewhat deoptimized compared to
the previous one). We also need to interrupt the execution of the wrong
code and continue execution from that point in the new code. For that,
we need a continuation-based on-stack-code-replacement mechanism
implemented purely using existing JVM capabilities (bytecode and method
handles).</p>
<p>For a detailed explanation of how optimistic types would work, please
refer to <a href="http://medianetwork.oracle.com/video/player/2630340183001">Lagergren/JVMLS 2013</a></p>
<p><strong>Rationale</strong></p>
<p>With JavaScript, it is more often than not impossible to precisely
infer the data type of many expressions statically. Such expressions
can conservatively be treated as Objects, but such treatment severely
reduces the speed of execution. By starting out with the computationally
fastest types and doing just-in-time gradual deoptimization to slower
types, we end up with the fastest code shape that can operate on the
given input.</p>
<p><strong>Primitive field representation</strong></p>
<p>Field representation in Nashorn (objects in the scope are
represented as fields in Java classes) needs to be modified to be
something else than just "Object". We have experimented with a pair of
long/Object fields, using the long for all primitive types, and the
Objects for non primitives. Microbenchmarks have shown that this gives
us significant performance improvements in statically provable
primitive types, but in the general case, again we have too little
information for speedup. This will most likely be much, much better if
we mate it with the optimistic approach, and early experiments have
confirmed this.</p>
<p>We should also, in the interest of memory overhead, investigate the
earlier POC for <code>sun.misc.TaggedArray</code> that is a "both reference and
primitive, either / or" shortcut to get around the Object constraints.</p>
<p><strong>Warmup is slow</strong></p>
<p>For warmup we might need to do lazy code generation, which is already
implemented but not enabled. For some projects, like "npm" in the
node.js to Java port, we have shown that lazy code generation indeed
gives us significant startup performance. The JVM needs to do a lot of
warmup work too, though: see below.</p>
<p><strong>Classic IR optimizations</strong></p>
<p>We can do some classic code optimizations in the byte code, because we
know more than the VM. For example, in the loop</p>
<pre><code>var sum = 0;
for (i = 0; i &lt; 10; x++) {
    sum += y;
}</code></pre>
<p><code>y</code> might be a method with side effects and <code>valueOf</code> overridden, but if
we check that before the loop we can turn the code into</p>
<pre><code>var sum = 0;
 var ytmp = y; //which will throw UnwarrantedOptimismException i y is not a nice primitive
 for (i = 0; i &lt; 10; x++) {
     sum += ytmp;
 }</code></pre>
<p><strong>Use def analysis</strong></p>
<p>We also need to superimpose a CFG on top of the AST to be able to do
better use/def chains, which would enable us to get rid of assumptions
like</p>
<pre><code>if (x) {
   z = y &amp; f;
   operation_on_z(z)
} else {
   z = "string";
}</code></pre>
<p>so that we can use <code>z</code> as an <code>int</code> in the true case statically, which we
can, but right now, we conservatively assume <code>z</code> to be an <code>Object</code> due to
the else case throughout the entire method.</p>
<p><a href="http://fileadmin.cs.lth.se/sde/publications/papers/2012-Soderberg-SCP-PrePrint.pdf">See S&#246;derberg et al</a>,
who describe a similar methodology</p>
<h3 id="For-the-JVM">For the JVM</h3>
<p><strong>Intrinsics for exact math</strong></p>
<p>The various <code>java.lang.Math</code> operations for exact arithmetic (which
throw <code>ArithmethicException</code> on overflow) must be intrinsified. Every
optimistic JavaScript addition will have to check for overflow using
this mechanism, and unless it compiles to just an arithmetic operation
and a jump-on-overflow instruction, the overhead will be too great.</p>
<p>This is needed to preserve JavaScript semantics.</p>
<p><strong>Invoke</strong></p>
<p>The <code>MethodHandle.invoke</code> (not <code>invokeExact</code>) case (used to implement,
e.g., <code>apply</code>) needs to be faster. According to John Rose, no
optimization has taken place there so far, but it is very common that
boxing gets in the way.</p>
<p>The JRockit implementation of invokedynamic could turn the test method
from the example:</p>
<pre><code>public class Test {
      private final static MethodHandle CALC = MethodHandles.publicLookup().findStatic(Test.class, "calc", int.class, int.class, Object.class);

      static int test() throws Throwable {
          MethodHandle mh = CALC;
          Object aString = "A";
          int a = mh.invoke(1, aString);
          int b = mh.invoke(2, "B");
          Integer c = mh.invoke((Integer)3, 3);
          return a+b+c;
      }

      static int calc(int x, Object o) {
          return x + o.hashCode();
      }
}</code></pre>
<p>into a simple <code>return 140</code>. For HotSpot to do the same, an improvement
at least to the generic invoke case is required.</p>
<p><a href="http://medianetwork.oracle.com/video/player/589206011001">Source: Fredrik &#214;hrstr&#246;m's talk from JavaOne 2010</a></p>
<p><a href="https://blogs.oracle.com/ohrstrom/">Source: Fredrik &#214;hrstr&#246;m's blog</a></p>
<p><strong><code>java.lang.invoke</code> and LambdaForms</strong></p>
<p>The LambdaForms implementation needs to be improved. They contribute to a
lot of bytecode generation which makes warmup an issue (even more than
just having a bootstrap method per invokedynamic, which is unavoidable).
This can probably be alleviated with lambda form caching. JIT profile
information must not be polluted by this, though.</p>
<p>Lambda form interpretation overhead is another issue that we frequently
bump into. Given that Nashorn reaches a steady state, there should be
no more MethodHandles created and no more lambda forms interpreted.</p>
<p>Cached lambda forms should be retrieved as their compiled versions
upon trying to reinterpret them so that they never are interpreted
again if they have once been compiled.</p>
<p>Furthermore, we have to ensure that all combinators in
<code>java.lang.invoke</code> have a fast path that avoids boxing or apply-like
semantics. Currently, the catchException combinator is an example of
something we commonly use that needs that required optimization. Other
examples probably exist, especially in the cases that take many
parameters.</p>
<p><strong>Better type analysis is needed</strong></p>
<p>Early experiments show that me miss optimization opportunities to
inline virtual dispatch if type analysis is too conservative. As
JavaScript uses plenty of type guards to due to its dynamic nature,
this must be addressed.</p>
<p>What we need to do in the JVM has been less explored, and we will
require at least one full time compiler team resource to help us here.</p>
<h2 id="Testing">Testing</h2>
<p>For semantic correctness the standard Nashorn test suites will do.</p>
<p>For performance verification existing benchmarks will do, and should
be augmented with a microbenchmark suite that tests invalidations of
optimistic assumptions.</p>
<p>Any torture tests that are run for a long time by SQE should still
run to ensure that no reasource leakage is introduced.</p>
<h2 id="Risks-and-Assumptions">Risks and Assumptions</h2>
<p>The main risk is that the JIT still won't be able to generate efficient
code from our optimistic type information.</p>
<p>A risk is that bytecode might prove to be a too narrow representation
for efficient implementations of dynamic languages. We might need to be
a lot more explicit with our generated code, possibly inventing a
mechanism to communicate more information to HotSpot's JITs than can be
done with the current bytecode format. An existing example of a system
that can talk more directly with the JIT is the Truffle project at
Oracle Labs that tells the Graal compiler through annotations in the
Java based interpreter which assumptions to make. Experiments have
shown that this indeed can produce very good peak performance.</p>
<p>In the long run LambdaForms may have to be totally rewritten and
replaced with something else. The JRockit JVM basically just generated
IR for a callsite and fed it back to the JIT compiler, which enabled
all its optimizations like constant propagation and unboxing removal
to run transparently on the callsite. This is not as simple in C2, due
to its various issues with graph splicing, platform dependencies and
global dependencies.</p>
<p>Finally, as code generation becomes optimistic, our warmup time will
increase.</p>
<h2 id="Dependences">Dependences</h2>
<ul>
<li>
<p>The Hotspot JITs.</p>
</li>
<li>
<p>HotSpot code generation improvements.</p>
</li>
<li>
<p>Efficient MethodHandles implementation.</p>
</li>
</ul>
<h2 id="Impact">Impact</h2>
<p>There are no compatibility problems, as far as we can tell. Given that
footprint and warmup are kept down according to the above, this should
be a drop in replacement for current Nashorn versions.</p>
</div></div><div id="sidebar"><div id="openjdk-sidebar-logo"><a href="/"><img alt="OpenJDK logo" src="/images/openjdk-small.png" /></a></div><div class="links"><div class="links"><a href="/workshop"><b>Workshop</b></a></div></div><div class="links"><div class="link"><a href="/faq/">OpenJDK FAQ</a></div><div class="link"><a href="/install/">Installing</a></div><div class="link"><a href="/contribute/">Contributing</a></div><div class="link"><a href="/sponsor/">Sponsoring</a></div><div class="link"><a href="/guide/">Developers' Guide</a></div><div class="link"><a href="/groups/vulnerability/report">Vulnerabilities</a></div></div><div class="links"><div class="links"><a href="//mail.openjdk.java.net">Mailing lists</a></div><div class="link"><a href="/irc">IRC</a>
                      &#183; <a href="https://wiki.openjdk.java.net">Wiki</a></div></div><div class="links"><div class="links"><a href="/bylaws">Bylaws</a> &#183; <a href="/census">Census</a></div><div class="link"><a href="/legal/">Legal</a></div></div><div class="links"><div class="links"><a href="/jeps/0"><b>JEP Process</b></a></div></div><div class="links"><div class="link search"><form method="get" action="https://www.google.com/search"><input id="searchBox" style="color: gray" type="text" name="q" size="10" maxlength="255" value="search" /><input type="hidden" name="sitesearch" value="openjdk.java.net" /></form></div></div><div class="links"><div class="about">Source code</div><div class="link"><a href="//hg.openjdk.java.net">Mercurial</a></div><div class="link">Bundles (<a href="http://download.java.net/openjdk/jdk6">6</a>)</div></div><div class="links"><div class="about">Groups</div><div class="link"><a href="/groups/">(overview)</a></div><div class="link"><a href="/groups/2d">2D Graphics</a></div><div class="link"><a href="/groups/adoption">Adoption</a></div><div class="link"><a href="/groups/awt">AWT</a></div><div class="link"><a href="/groups/build">Build</a></div><div class="link"><a href="/groups/csr">Compatibility &amp; Specification Review</a></div><div class="link"><a href="/groups/compiler">Compiler</a></div><div class="link"><a href="/groups/conformance">Conformance</a></div><div class="link"><a href="/groups/core-libs">Core Libraries</a></div><div class="link"><a href="/groups/gb">Governing Board</a></div><div class="link"><a href="/groups/hotspot">HotSpot</a></div><div class="link"><a href="/groups/ide-support">IDE Tooling &amp; Support</a></div><div class="link"><a href="/groups/i18n">Internationalization</a></div><div class="link"><a href="/groups/jmx">JMX</a></div><div class="link"><a href="/groups/members">Members</a></div><div class="link"><a href="/groups/net">Networking</a></div><div class="link"><a href="/groups/nb-projects">NetBeans Projects</a></div><div class="link"><a href="/groups/porters">Porters</a></div><div class="link"><a href="/groups/quality">Quality</a></div><div class="link"><a href="/groups/security">Security</a></div><div class="link"><a href="/groups/serviceability">Serviceability</a></div><div class="link"><a href="/groups/sound">Sound</a></div><div class="link"><a href="/groups/swing">Swing</a></div><div class="link"><a href="/groups/vulnerability">Vulnerability</a></div><div class="link"><a href="/groups/web">Web</a></div></div><div class="links"><div class="about">Projects</div><div class="link"><a href="/projects/">(overview)</a></div><div class="link"><a href="/projects/amber">Amber</a></div><div class="link"><a href="/projects/anno-pipeline">Annotations Pipeline 2.0</a></div><div class="link"><a href="/projects/audio-engine">Audio Engine</a></div><div class="link"><a href="/projects/build-infra">Build Infrastructure</a></div><div class="link"><a href="/projects/caciocavallo">Caciocavallo</a></div><div class="link"><a href="/projects/closures">Closures</a></div><div class="link"><a href="/projects/code-tools">Code Tools</a></div><div class="link"><a href="/projects/coin">Coin</a></div><div class="link"><a href="/projects/cvmi">Common VM Interface</a></div><div class="link"><a href="/projects/compiler-grammar">Compiler Grammar</a></div><div class="link"><a href="/projects/detroit">Detroit</a></div><div class="link"><a href="/projects/dio">Device I/O</a></div><div class="link"><a href="/projects/duke">Duke</a></div><div class="link"><a href="/projects/font-scaler">Font Scaler</a></div><div class="link"><a href="/projects/fbtoolkit">Framebuffer Toolkit</a></div><div class="link"><a href="/projects/graal">Graal</a></div><div class="link"><a href="/projects/graphics-rasterizer">Graphics Rasterizer</a></div><div class="link"><a href="/projects/harfbuzz">HarfBuzz Integration</a></div><div class="link"><a href="/projects/icedtea">IcedTea</a></div><div class="link"><a href="/projects/jdk6">JDK 6</a></div><div class="link"><a href="/projects/jdk7">JDK 7</a></div><div class="link"><a href="/projects/jdk7u">JDK 7 Updates</a></div><div class="link"><a href="/projects/jdk8">JDK 8</a></div><div class="link"><a href="/projects/jdk8u">JDK 8 Updates</a></div><div class="link"><a href="/projects/jdk9">JDK 9</a></div><div class="link"><a href="/projects/jdk">JDK</a>
      (&#8230;
       <a href="/projects/jdk/12">12</a>,
       <a href="/projects/jdk/13">13</a>,
       <a href="/projects/jdk/14">14</a>)</div><div class="link"><a href="/projects/jdk-updates">JDK Updates</a></div><div class="link"><a href="/projects/javadoc-next">JavaDoc.Next</a></div><div class="link"><a href="/projects/jigsaw">Jigsaw</a></div><div class="link"><a href="/projects/kona">Kona</a></div><div class="link"><a href="/projects/kulla">Kulla</a></div><div class="link"><a href="/projects/lambda">Lambda</a></div><div class="link"><a href="/projects/lanai">Lanai</a></div><div class="link"><a href="/projects/locale-enhancement">Locale Enhancement</a></div><div class="link"><a href="/projects/loom">Loom</a></div><div class="link"><a href="/projects/jmm">Memory Model Update</a></div><div class="link"><a href="/projects/metropolis">Metropolis</a></div><div class="link"><a href="/projects/jmc">Mission Control</a></div><div class="link"><a href="/projects/mobile">Mobile</a></div><div class="link"><a href="/projects/modules">Modules</a></div><div class="link"><a href="/projects/mlvm">Multi-Language VM</a></div><div class="link"><a href="/projects/nashorn">Nashorn</a></div><div class="link"><a href="/projects/nio">New I/O</a></div><div class="link"><a href="/projects/openjfx">OpenJFX</a></div><div class="link"><a href="/projects/panama">Panama</a></div><div class="link"><a href="/projects/penrose">Penrose</a></div><div class="link"><a href="/projects/aarch32-port">Port: AArch32</a></div><div class="link"><a href="/projects/aarch64-port">Port: AArch64</a></div><div class="link"><a href="/projects/bsd-port">Port: BSD</a></div><div class="link"><a href="/projects/haiku-port">Port: Haiku</a></div><div class="link"><a href="/projects/macosx-port">Port: Mac OS X</a></div><div class="link"><a href="/projects/mips-port">Port: MIPS</a></div><div class="link"><a href="/projects/ppc-aix-port">Port: PowerPC/AIX</a></div><div class="link"><a href="/projects/s390x-port">Port: s390x</a></div><div class="link"><a href="/projects/portola">Portola</a></div><div class="link"><a href="/projects/sctp">SCTP</a></div><div class="link"><a href="/projects/skara">Skara</a></div><div class="link"><a href="/projects/shenandoah">Shenandoah</a></div><div class="link"><a href="/projects/sumatra">Sumatra</a></div><div class="link"><a href="/projects/threeten">ThreeTen</a></div><div class="link"><a href="/projects/tiered-attrib">Tiered Attribution</a></div><div class="link"><a href="/projects/tsan">Tsan</a></div><div class="link"><a href="/projects/type-annotations">Type Annotations</a></div><div class="link"><a href="/projects/xrender">XRender Pipeline</a></div><div class="link"><a href="/projects/valhalla">Valhalla</a></div><div class="link"><a href="/projects/verona">Verona</a></div><div class="link"><a href="/projects/visualvm">VisualVM</a></div><div class="link"><a href="/projects/zero">Zero</a></div><div class="link"><a href="/projects/zgc">ZGC</a></div></div><div class="links"><div class="about">Tools</div><div class="link"><a href="http://java.sun.com/javase/downloads/index.jsp">Java SE</a></div><div class="link"><a href="http://mercurial-scm.org/mercurial/">Mercurial</a></div><div class="link"><a href="/jtreg/index.html">jtreg harness</a></div></div><div class="links"><div class="about">Related</div><div class="link"><a href="http://planetjdk.org">Planet JDK</a></div><div class="link"><a href="http://java.sun.com">java.sun.com</a></div><div class="link"><a href="http://jcp.org">Java Community Process</a></div><div class="link"><a href="//jdk.java.net">JDK GA/EA Builds</a></div></div><div class="buttons"><a href="http://oracle.com"><img alt="Oracle logo" src="/images/oracle.png" /></a></div></div><div id="footer">

        &#169; 2019 Oracle Corporation and/or its affiliates
        <br /><a href="/legal/tou/">Terms of Use</a>
        &#183;
        
            License: <a href="/legal/gplv2+ce.html">GPLv2</a>
        &#183; <a href="http://www.oracle.com/us/legal/privacy/">Privacy</a>
        &#183; <a href="http://www.oracle.com/us/legal/third-party-trademarks/third-party-trademarks-078568.html">Trademarks</a></div><SCRIPT type="text/javascript">
  var sc_project=2527440;
  var sc_invisible=1;
  var sc_partition=24;
  var sc_security="d832a704";
  var sc_remove_link=1;
  </SCRIPT><script type="text/javascript" src="https://www.statcounter.com/counter/counter_xhtml.js" async="yes"></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/2527440/0/d832a704/1/" alt="web statistics" /></div></noscript></body></html>
